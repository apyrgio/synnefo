Design document for attach/detach functionality
===============================================

The goal of this design document is to initiate the discussion regarding the
implementation of the attach/detach operations for Synnefo Volumes. We will
first document what is the current state of Synnefo (0.16.1 as of writing this)
regarding Volumes, explain some Ganeti issues that make the implementation a
bit tricky and then provide a design draft.

Current state and shortcomings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since 0.16, Synnefo has provided an API for Volumes that is compatible to the
Openstack Cinder API (see `Block Storage API Guide
<https://www.synnefo.org/docs/synnefo/latest/blockstorage-api-guide.html>`_).
Using this API, the user can create Volumes, update and list them. There is just
a minor nitpick, that the user cannot create a Volume without specifying a VM
that it will be attached to.

Moreover, the user currently has no way to detach a volume from a VM and attach
it to another.

Ganeti issues
~~~~~~~~~~~~~

Ganeti 2.14 has added support for the attach/detach volume operations. However,
these operations still have some limitations and caveats.

Limitations
-----------

1. There is no ``gnt-volume`` command. All volume operations happen within the
   context of a VM modification, and more specifically from ``gnt-instance
   modify --disk ...``.  This means that all volumes must be created with a VM
   as target and detached volumes can be referenced only for attach operations.

2. The attach/detach operations work only within a Ganeti cluster. This means
   that there is no **pure** Ganeti way to detach a volume from a VM in
   **gnt-cluster-1** and attach it to a VM in **gnt-cluster-2**.

3. A volume can be attached to a VM if and only if that VM can access the
   volume data. This means that e.g. a DRBD volume can only be attached to DRBD
   VMs whose primary and secondary nodes match that of the volume.

Caveats
-------

1. The volume name that is generated by Ganeti and used by Synnefo follows
   roughly this form: **UUID.disk_template.diskX**. This means that
   during the disk's lifetime, its name can change. Note that Ganeti can
   provide two names to the ExtStorage scripts:

   * ``VOL_NAME``: A unique name that Ganeti generates for the volume.
   * ``VOL_CNAME``: A unique name that the user (in our case Synnefo) creates
     for the volume.

   For more info, you can read the `related Ganeti doc
   <http://docs.ganeti.org/ganeti/current/html/man-ganeti-extstorage-interface.html#common-environment>`_.
   Archipelago currently uses the former as the name for its volumes.

2. Ganeti does not support multiple disk templates for VMs.

3. Ganeti does not pass user-provided parameters for Ext templates during
   the removal of a disk.

Design overview
~~~~~~~~~~~~~~~

In this section, we will propose a way to decouple the **Create** operation
from the **Attach** operation and add a **Detach** operation. Also, we will
suggest an altered **Delete** operation from the existing one.

Before showing the design behind the above operations, we will list a few
compromises that are needed to make the attach/detach operations work:

1. Since the user is not aware of Ganeti nodes and clusters, we must provide an
   **Attach** operation that will work Synnefo-wide. This is achievable only
   with Archipelago volumes, which are visible from all Ganeti clusters.

2. In order to be able to reference the Archipelago volumes from different
   clusters, we have to resort in using the ``VOL_CNAME`` instead of
   ``VOL_NAME``, since the first will remain the same throughout the Volume's
   lifetime.

   This needs migration for the existing volumes, since until now, volumes were
   named using the ``VOL_NAME``. Currently, all volumes are created using the
   ``VOL_NAME``, but are given a ``VOL_CNAME`` by Cyclades. Archipelago
   addresses the volumes using the ``VOL_NAME`` but Cyclades addresses them
   using ``VOL_CNAME``. We need a way to sync the ``VOL_NAME`` and
   ``VOL_CNAME`` of each volume, so both Cyclades and Archipelago can directly
   address the same volume.

   One way would be to to rename Archipelago volumes from ``VOL_NAME`` to
   ``VOL_CNAME``.  Given the current Archipelago mapfile design, this can be
   tricky and might require detaching the volume / shutting the VM down.
   Another way would be to alter the ``VOL_CNAME`` of the current volumes to
   match the current ``VOL_NAME``. This needs to be done in both Ganeti and
   Cyclades.

3. We must write some Ganeti code in order to allow the passing of
   user-provided parameters for Ext templates during disk remove.

We will now proceed with the design of each action:

Create
------

The **Create** operation currently is tightly coupled with the **Attach**
operation, and requires the presence of a ``server_id`` argument in order to
create and attach a Volume to a VM at once. In order to decouple these two
operations and maintain backwards compatibility, we can make this argument
optional.

Therefore, a **Create** operation with no ``server_id`` provided will simply
do the checks that it does now and stop at the step where it stores a Volume
entry in the database. The actual volume will be created once the user attempts
to attach it to an instance.

Attach
------

The **Attach** operation will have two targets, a VM id and a Volume id. This
operation will continue from where **Create** left off, i.e. it will send a
disk creation job (``gnt-instance modify --disk
-1:add,name=<VOL_CNAME>,reuse_data=True``) to Ganeti. The ``reuse_data`` Ext
parameter should inform Archipelago to not create a new volume but reuse an
existing one. Note that there are two cases here:

1. **The volume has not been attached to an instance before:** In this case, we
   will inform the ExtStorage script to create the Volume in Archipelago, using
   the ``VOL_CNAME`` as its name.

2. **The volume has been attached to an instance before:** This means that the
   Volume has been initialized. In this case, we will inform the ExtStorage
   script to simply map the existing volume to the instance, using the
   ``VOL_CNAME`` as identifier.

Detach
------

The **Detach** operation will not use the Ganeti **detach** operation as one
would expect, but the **remove** operation (``gnt-instance modify --disk
<VOL_CNAME>:remove,keep_data=True``), in conjunction with an ExtStorage
parameter (``keep_data``) that will inform the ExtStorage script to keep the
volume intact in Archipelago.

The rationale behind this choice is to avoid having duplicate references to the
same volume from different clusters, since the remove operation must operate
only in one. Also, a detached Ganeti volume cannot be destroyed from Ganeti
(see limitation 1), therefore it must be done from Archipelago. In this case,
we do not want any reference of this volume to exist in any Ganeti cluster.

Delete
------

The **Delete** operation will have two cases:

1. **The volume is attached to an instance:** In this case, we will issue a remove
   operation (``gnt-instance modify --disk <VOL_CNAME>:remove``), as we are
   currently doing.

2. **The volume is detached:** Although at this point the volume is not in any
   Ganeti config and can be safely removed using a ``vlmc`` command, we need a
   way to receive callbacks for this action and to make sure that the remove
   has succeeded in order to change quotas etc. We could extend the
   ``snf-dispatcher`` to support Archipelago as a backend, but after
   consideration, we decided that it would be best if we reused the existing
   logic and removed the disk through Ganeti. This means that a detached volume
   must be attached to a dummy instance and then be removed. The attachment to
   the dummy instance must be transparent to the user.

API extensions
~~~~~~~~~~~~~~

Synnefo's current API implementation regarding Volumes is almost fully
compatible with the OpenStack **Cinder** and **Nova** (os-volume_attachments)
API. The only change that it needs to be marked as fully compatible is to lift
the requirement of a server id during the creation of a Volume. The user will
still be able to provide a server id, in order to retain the backwards
compatibility, however it should no longer be necessary.
